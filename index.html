<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>人狼カードゲーム MVP（仕様検証用）</title>
  <style>
    body { font-family: system-ui, -apple-system, "Segoe UI", sans-serif; margin: 12px; }
    .row { display:flex; gap:12px; flex-wrap:wrap; align-items:flex-start; }
    .panel { border:1px solid #ccc; border-radius:8px; padding:10px; }
    .panel h3 { margin:0 0 8px 0; font-size:16px; }

    .players { display:grid; grid-template-columns: repeat(2, minmax(320px, 1fr)); gap:10px; }
    .player { border:1px solid #bbb; border-radius:8px; padding:10px; }
    .player.dead { opacity:0.55; }

    .slots { display:grid; grid-template-columns: repeat(9, 1fr); gap:6px; margin-top:8px; }
    .slot{
      border:1px solid #888; border-radius:6px; padding:8px 4px;
      text-align:center; cursor:pointer; user-select:none;
      background:#fff;
      font-size:12px; line-height:1.25;
      min-height:72px;
      display:flex; flex-direction:column; justify-content:center;
      position:relative; /* 角アイコン用 */
      overflow:hidden;
    }
    .slot .role{ font-size:11px; margin-top:2px; opacity:0.85; }

    /* === 死亡：グレースケール化（黒塗りではなく “暗く”） === */
    .slot.deadslot{
      background:#1f1f1f;
      border-color:#333;
      color:#aaa;
      cursor:not-allowed;
      filter: grayscale(1) brightness(0.65) contrast(0.95);
      opacity:0.85;
    }
    .slot.deadslot .role{ display:none; }

    /* === 選べる/選べないの見た目を強化 === */
    .slot.canPick{
      outline:3px solid #2a7;
      box-shadow: 0 0 0 2px rgba(42,170,119,0.18), 0 0 12px rgba(42,170,119,0.45);
      animation: pickPulse 1.1s ease-in-out infinite;
    }
    @keyframes pickPulse{
      0%,100%{ transform: translateZ(0) scale(1.00); }
      50%    { transform: translateZ(0) scale(1.02); }
    }
    .slot.cantPick{
      filter: grayscale(0.35) brightness(0.78);
      opacity:0.55;
    }
    .slot.hintpick{ outline:3px dashed #777; opacity:0.78; }

    .badge{ display:inline-block; padding:2px 6px; border:1px solid #999; border-radius:999px; font-size:12px; margin-left:6px; }
    .btn{ padding:8px 10px; border:1px solid #888; border-radius:8px; background:#fff; cursor:pointer; }
    .btn:disabled{ opacity:0.5; cursor:not-allowed; }
    .mini{ font-size:12px; color:#333; }

    .log, .stock{
      white-space:pre-wrap;
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      font-size:12px;
      overflow:auto;
    }
    .log{ max-height:320px; }
    .stock{ max-height:240px; }

    select{ padding:6px 8px; border-radius:8px; }
    .danger{ color:#b00; font-weight:700; }
    .hint{ color:#0a5; font-weight:700; }
    .big{ font-size:14px; font-weight:700; }

    .noteBox{
      margin-top:6px;
      padding:6px 8px;
      border:1px dashed #aaa;
      border-radius:8px;
      font-size:12px;
      color:#333;
      background:#fafafa;
    }

    /* === 役職アイコン（スロット中央） === */
    .roleIcon{
      width:40px;
      height:40px;
      object-fit:contain;
      margin:4px auto 0;
      image-rendering: pixelated;
      pointer-events:none;
    }

    /* === 角アイコン（盾/反転/白黒） === */
    .cornerIcon{
      position:absolute;
      width:18px;
      height:18px;
      object-fit:contain;
      image-rendering: pixelated;
      pointer-events:none;
      filter: drop-shadow(0 1px 1px rgba(0,0,0,0.35));
    }
    .cornerTL{ left:4px; top:4px; }
    .cornerTR{ right:4px; top:4px; }
    .cornerBR{ right:4px; bottom:4px; }

    /* === ストック枠（背景画像）=== */
    .stockFrame{
      background-image:url("img/frame_512.png");
      background-size:contain;
      background-repeat:no-repeat;
      padding:18px 18px 18px 18px;
      min-height:120px;
    }
    .stockRow{
      display:flex;
      align-items:center;
      gap:6px;
      padding:2px 0;
    }
    .stockIcon{
      width:16px;
      height:16px;
      object-fit:contain;
      image-rendering: pixelated;
      pointer-events:none;
    }
  </style>
</head>

<body>
<img src="img/wolf_256.png" style="width:80px;height:80px;border:1px solid red;">
  <div class="row">
    <div class="panel" style="flex:1; min-width:360px;">
      <h3>操作</h3>
      <div class="row">
        <button id="btnNew" class="btn">新規ゲーム</button>
        <button id="btnReset" class="btn">同じ配りでリセット</button>
        <button id="btnAutoOne" class="btn">タイムアウト（今の手番だけ）</button>
      </div>

      <div style="margin-top:10px;" class="row">
        <div class="panel" style="flex:1; min-width:320px;">
          <h3>現在状態</h3>
          <div id="status"></div>

          <div style="margin-top:8px;" class="row">
            <button id="btnRound0MadOff" class="btn">Round0: 狂人OFF</button>
            <button id="btnMadKeep" class="btn">狂人：維持/スキップ</button>
            <button id="btnMadClear" class="btn">狂人：反転解除</button>
            <button id="btnGuardKeep" class="btn">狩人：維持</button>
            <button id="btnAbsentOk" class="btn">不在→OK（スキップ）</button>
          </div>

          <div class="mini" style="margin-top:8px;">
            ・クリックで対象スロット選択（選択可能スロットは緑で光る）<br/>
            ・選べないスロットは暗く表示（対象外がひと目で分かる）<br/>
            ・自分（View as）のカード役職だけ表示（他人は非表示）<br/>
            ・P2〜P4は自動（全部タイムアウト扱い）<br/>
            ・守り先／反転対象／狂人ON/OFFは他人に見えない（View as本人のみ）<br/>
            ・狩人は「狩人カード」「人狼カード」は守れない<br/>
            ・占いは毎回行う（結果は全体公開）<br/>
            ・占い結果はスロットに反映（全体公開）。前回と色が変わったら「（変化）」が付く
          </div>
        </div>

        <div class="panel" style="min-width:320px;">
          <h3>占い履歴（全体公開）</h3>
          <div class="mini">誰がどこを占って何色だったか（全体公開）</div>
          <div id="stock" class="stock stockFrame" style="margin-top:8px;"></div>
        </div>

        <div class="panel" style="min-width:280px;">
          <h3>表示視点（デバッグ）</h3>
          <div class="row" style="align-items:center;">
            <div>View as:</div>
            <select id="viewAs"></select>
          </div>
          <div id="mediumInfo" class="mini" style="margin-top:10px;"></div>
        </div>
      </div>
    </div>
  </div>

  <div class="panel" style="margin-top:12px;">
    <h3>プレイヤー</h3>
    <div id="players" class="players"></div>
  </div>

  <div class="panel" style="margin-top:12px;">
    <h3>全体ログ（最終アクションまで保持）</h3>
    <div id="log" class="log"></div>
  </div>

  <script>
/* ==============
   まず、エラーが起きたら画面に表示
============== */
window.onerror = (msg, src, line, col) => {
  const el = document.getElementById("status");
  if (el) el.innerHTML = `<span class="danger">JSエラー:</span> ${msg}<br>${line}:${col}`;
};

/* ======================
   設定・定義・共通
====================== */
const CONFIG = {
  humanPlayerId: 0,
  autoPlayers: true,
  autoSafetySteps: 600,
};

const ROLES = {
  WOLF: "人狼",
  MAD: "狂人",
  SEER: "占い",
  GUARD: "狩人",
  MEDIUM: "霊媒",
  VILLAGER: "村人",
};

const PHASES = {
  ROUND0_MAD: "Round0:狂人（反転対象選択 or OFF）",
  ROUND0_GUARD: "Round0:狩人守り設定",
  SEER: "占い",
  LYNCH: "吊り",
  MAD: "狂人設定",
  GUARD: "狩人守り設定",
  BITE: "噛み",
  END: "終了",
};

/* ===== 画像（imgフォルダ） ===== */
const ROLE_ICON = {
  [ROLES.VILLAGER]: "img/clover_256.png",
  [ROLES.MEDIUM]:   "img/comma_256.png",
  [ROLES.SEER]:     "img/crystalball_256.png",
  [ROLES.GUARD]:    "img/emblem_256.png",
  [ROLES.MAD]:      "img/joker_256.png",
  [ROLES.WOLF]:     "img/wolf_256.png",
};
const MARK_ICON = {
  WHITE: "img/orb_blue_128.png",
  BLACK: "img/orb_128.png",
};
const BADGE_ICON = {
  SHIELD: "img/shield_128.png",
  ROTATE: "img/rotate_128.png",
};

function shuffle(arr, rnd=Math.random) {
  const a = arr.slice();
  for (let i=a.length-1;i>0;i--) {
    const j = Math.floor(rnd()*(i+1));
    [a[i],a[j]] = [a[j],a[i]];
  }
  return a;
}

function nowStamp(){
  const d=new Date();
  const hh=String(d.getHours()).padStart(2,"0");
  const mm=String(d.getMinutes()).padStart(2,"0");
  const ss=String(d.getSeconds()).padStart(2,"0");
  return `${hh}:${mm}:${ss}`;
}

let baseDeal = null;
let game = null;

/* ======================
   初期化
====================== */
function makeNewGame(fixedDeal=null){
  // 合計9枚：村人×3
  const deck = [
    ROLES.WOLF, ROLES.WOLF,
    ROLES.MAD,
    ROLES.SEER,
    ROLES.GUARD,
    ROLES.MEDIUM,
    ROLES.VILLAGER, ROLES.VILLAGER, ROLES.VILLAGER
  ];

  const players = [];
  for (let p=0;p<4;p++){
    const roles = fixedDeal ? fixedDeal[p].slice() : shuffle(deck);
    const slots = roles.map(r => ({
      role: r,
      dead: false,
      publicSeer: { last: null, changedLast: false, byActorId: null }, // 占い結果（全体公開）
    }));

    players.push({
      id: p,
      alive: true,

      slots,

      madEnabled: false,
      invertIndex: null,   // 反転対象（本人以外に非公開）
      madUsed: false,      // ★反転が1回でも発動したら true（以後は選択不可）

      guardIndex: null,    // 守り（本人以外に非公開）

      mediumWolfSnapshot: null, // 霊媒死亡後の固定表示
    });
  }

  return {
    players,
    phase: PHASES.ROUND0_MAD,
    turn: 0,
    winners: [],
    over: false,
    log: [],
    stock: { seerHistory: [], actionNo: 0 },
  };
}

function logPush(text){
  if(!game) return;
  game.log.push(`[${nowStamp()}] ${text}`);
}
function stockPushSeer(item){
  game.stock.actionNo += 1;
  game.stock.seerHistory.push({ ...item, ts: nowStamp(), actionNo: game.stock.actionNo });
}

function countRoleRemaining(pl, role){
  return pl.slots.reduce((acc,s)=>acc + ((!s.dead && s.role===role)?1:0), 0);
}
function hasRoleAlive(pl, role){ return countRoleRemaining(pl, role) > 0; }
function wolfCount(pl){ return countRoleRemaining(pl, ROLES.WOLF); }
function villageRolesTotal(pl){
  return countRoleRemaining(pl, ROLES.SEER) + countRoleRemaining(pl, ROLES.GUARD) + countRoleRemaining(pl, ROLES.MEDIUM);
}
function findRoleIndex(pl, role){
  for(let i=0;i<pl.slots.length;i++){
    if(pl.slots[i].role===role) return i;
  }
  return null;
}

function nextAliveIndex(from, dir){
  const n = game.players.length;
  for(let step=1; step<=n; step++){
    const idx = (from + dir*step + n) % n;
    if(game.players[idx].alive) return idx;
  }
  return null; // ★生存者1人等で null あり得る
}
function leftPlayerIndex(actorId){ return nextAliveIndex(actorId, -1); }
function rightPlayerIndex(actorId){ return nextAliveIndex(actorId, +1); }

function getAliveSlotIndices(pl){
  const res = [];
  for(let i=0;i<pl.slots.length;i++){
    if(!pl.slots[i].dead) res.push(i);
  }
  return res;
}

function getGuardableSlotIndices(pl){
  const res = [];
  for(let i=0;i<pl.slots.length;i++){
    const s = pl.slots[i];
    if(s.dead) continue;
    if(s.role === ROLES.GUARD) continue;
    if(s.role === ROLES.WOLF) continue;
    res.push(i);
  }
  return res;
}

/* ======================
   ルール処理
====================== */
function killSlot(playerId, slotIndex){
  const pl = game.players[playerId];
  if(!pl.alive) return;
  const slot = pl.slots[slotIndex];
  if(slot.dead) return;

  slot.dead = true;
  // 占いマークは「残す」方針なら消さない（ここでは消さない）
  // slot.publicSeer は維持

  // 反転対象が死んだら解除
  if(pl.invertIndex === slotIndex){
    pl.invertIndex = null;
    logPush(`P${playerId+1} 反転対象がDEAD → 反転解除`);
  }

  // 狂人カードが死んだら能力消滅
  if(slot.role === ROLES.MAD){
    pl.madEnabled = false;
    pl.invertIndex = null;
    pl.madUsed = true; // 発動済扱い（UI上も迷わない）
    logPush(`P${playerId+1} 狂人カードがDEAD → 能力消滅`);
  }

  // 霊媒が死んだ瞬間の狼数を固定
  if(slot.role === ROLES.MEDIUM){
    if(pl.mediumWolfSnapshot === null){
      pl.mediumWolfSnapshot = game.players.map(x => wolfCount(x));
      logPush(`P${playerId+1} 霊媒カードがDEAD → 霊媒表示は固定化`);
    }
  }

  // 狩人が死んだら守りは無効化
  if(slot.role === ROLES.GUARD){
    pl.guardIndex = null;
    logPush(`P${playerId+1} 狩人カードがDEAD → 守り無効`);
  }
}

function retireIfWolfZero(){
  for(const pl of game.players){
    if(pl.alive && wolfCount(pl)===0){
      pl.alive = false;

      // 見た目：全スロットDEAD
      for(let i=0;i<pl.slots.length;i++){
        pl.slots[i].dead = true;
        // 占いマークは残してよい → publicSeerは保持
      }

      pl.madEnabled = false;
      pl.invertIndex = null;
      pl.madUsed = true;
      pl.guardIndex = null;

      logPush(`P${pl.id+1} 人狼0 → 即リタイヤ（全スロットDEAD表示）`);

      // 霊媒保持者だったなら snapshot 固定
      if(pl.mediumWolfSnapshot === null && findRoleIndex(pl, ROLES.MEDIUM) !== null){
        pl.mediumWolfSnapshot = game.players.map(x => wolfCount(x));
      }
    }
  }
}

function checkWinnersAndEndIfAny(){
  const alive = game.players.filter(p=>p.alive);
  if(alive.length === 0) return;

  const winners = [];
  for(const pl of alive){
    const othersAllRetired = game.players.every(x => x.id===pl.id ? true : !x.alive);
    if(othersAllRetired && wolfCount(pl) >= 1) winners.push(pl.id);
  }

  if(winners.length > 0){
    game.winners = winners;
    game.over = true;
    game.phase = PHASES.END;
    logPush(`勝利確定 → 勝者: ${winners.map(id=>`P${id+1}`).join(", ")}`);
  }
}

function updateAfterKill(){
  retireIfWolfZero();
  checkWinnersAndEndIfAny();
}

function advanceRound0(){
  if(game.over) return;
  if(game.phase === PHASES.ROUND0_MAD){ game.phase = PHASES.ROUND0_GUARD; return; }

  if(game.phase === PHASES.ROUND0_GUARD){
    if(game.turn < 3){
      game.turn += 1;
      game.phase = PHASES.ROUND0_MAD;
    } else {
      game.turn = 0;
      game.phase = PHASES.SEER;
      logPush("Round0終了 → 通常ターン開始");
    }
  }
}

function advancePhase(){
  if(game.over) return;
  if(game.phase === PHASES.ROUND0_MAD || game.phase === PHASES.ROUND0_GUARD) return;

  const order = [PHASES.SEER, PHASES.LYNCH, PHASES.MAD, PHASES.GUARD, PHASES.BITE];
  const idx = order.indexOf(game.phase);
  if(idx === -1) return;

  if(idx < order.length - 1){
    game.phase = order[idx+1];
  } else {
    const next = nextAliveIndex(game.turn, +1);
    game.turn = (next === null) ? game.turn : next;
    game.phase = PHASES.SEER;
  }
}

function resolveSeer(actorId, targetId, slotIndex){
  const actor = game.players[actorId];
  const target = game.players[targetId];

  if(!hasRoleAlive(actor, ROLES.SEER)){
    logPush(`P${actorId+1} 占い不在 → OK（スキップ）`);
    advancePhase();
    return;
  }

  const slot = target.slots[slotIndex];
  if(slot.dead){
    logPush(`P${actorId+1} 占い: 対象がDEADで無効`);
    return;
  }

  let isBlack = (slot.role === ROLES.WOLF);
  let wasInverted = false;

  // 反転は「占われる側の狂人能力」（1回発動で終了）
  const targetMadAlive = hasRoleAlive(target, ROLES.MAD);
  if(!target.madUsed && target.madEnabled && targetMadAlive && target.invertIndex === slotIndex){
    isBlack = !isBlack;
    wasInverted = true;
    target.madUsed = true;     // ★発動済み
    target.invertIndex = null; // ★以後選択させない（UIも消す）
    logPush(`P${targetId+1} 狂人反転が発動 → 以後は選択不可（スキップのみ）`);
  }

  const res = isBlack ? "黒" : "白";
  const prev = slot.publicSeer.last;
  const changedLast = (prev !== null && prev !== res);

  // 全体公開：スロットに反映（最新のみ）
  slot.publicSeer = { last: res, changedLast, byActorId: actorId };
  stockPushSeer({ actorId, targetId, slotIndex, result: res, wasInverted, changedLast });

  const invTxt = wasInverted ? " ※反転" : "";
  const chgTxt = changedLast ? "（変化）" : "";
  logPush(`P${actorId+1} 占い → P${targetId+1} S${slotIndex+1} = ${res}${chgTxt}${invTxt}`);

  advancePhase();
}

function resolveLynch(actorId, targetId, slotIndex){
  const target = game.players[targetId];
  if(target.slots[slotIndex].dead) return;

  killSlot(targetId, slotIndex);
  logPush(`P${actorId+1} 吊り → P${targetId+1} S${slotIndex+1}（カード種別は非公開／対象スロットはDEAD）`);

  updateAfterKill();
  if(!game.over) advancePhase();
}

function resolveMadRound0Off(actorId){
  const pl = game.players[actorId];
  pl.madEnabled = false;
  pl.invertIndex = null;
  logPush(`P${actorId+1} Round0 狂人 → OFF`);
  advanceRound0();
}

function resolveMadRound0Pick(actorId, slotIndex){
  const pl = game.players[actorId];

  if(!hasRoleAlive(pl, ROLES.MAD)){
    pl.madEnabled = false;
    pl.invertIndex = null;
    logPush(`P${actorId+1} 狂人不在 → OK（OFF扱い）`);
    advanceRound0();
    return;
  }

  if(pl.slots[slotIndex].dead){
    logPush(`P${actorId+1} Round0 狂人 → DEADは選べない`);
    return;
  }

  pl.madEnabled = true;
  pl.invertIndex = slotIndex;
  logPush(`P${actorId+1} Round0 狂人 → 反転対象設定（非公開）`);
  advanceRound0();
}

function resolveMad(actorId, slotIndexOrNull){
  const pl = game.players[actorId];
  const madAlive = hasRoleAlive(pl, ROLES.MAD);

  if(!madAlive){
    pl.madEnabled = false;
    pl.invertIndex = null;
    pl.madUsed = true;
    logPush(`P${actorId+1} 狂人不在 → OK（スキップ）`);
    advancePhase();
    return;
  }

  // ★反転が一度でも発動したら以後はスキップのみ
  if(pl.madUsed){
    logPush(`P${actorId+1} 狂人：発動済み → OK（スキップのみ）`);
    advancePhase();
    return;
  }

  if(!pl.madEnabled){
    pl.invertIndex = null;
    logPush(`P${actorId+1} 狂人設定 → OFF（スキップ）`);
    advancePhase();
    return;
  }

  if(slotIndexOrNull === null){
    logPush(`P${actorId+1} 狂人設定 → 維持/スキップ`);
    advancePhase();
    return;
  }

  if(pl.slots[slotIndexOrNull].dead){
    logPush(`P${actorId+1} 狂人設定 → DEADは選べない`);
    return;
  }

  pl.invertIndex = slotIndexOrNull;
  logPush(`P${actorId+1} 狂人設定 → 反転対象変更（非公開）`);
  advancePhase();
}

function resolveMadClear(actorId){
  const pl = game.players[actorId];
  if(!hasRoleAlive(pl, ROLES.MAD)){
    pl.madEnabled = false;
    pl.invertIndex = null;
    pl.madUsed = true;
    logPush(`P${actorId+1} 狂人不在 → OK（スキップ）`);
    advancePhase();
    return;
  }
  if(pl.madUsed){
    logPush(`P${actorId+1} 狂人：発動済み → OK（スキップのみ）`);
    advancePhase();
    return;
  }
  pl.invertIndex = null;
  logPush(`P${actorId+1} 狂人：反転解除（非公開）`);
  advancePhase();
}

function resolveGuard(actorId, slotIndex){
  const pl = game.players[actorId];

  if(!hasRoleAlive(pl, ROLES.GUARD)){
    pl.guardIndex = null;
    const phaseLabel = (game.phase === PHASES.ROUND0_GUARD) ? "Round0 狩人" : "狩人";
    logPush(`P${actorId+1} ${phaseLabel}不在 → OK（スキップ）`);
    if(game.phase === PHASES.ROUND0_GUARD) advanceRound0(); else advancePhase();
    return;
  }

  const slot = pl.slots[slotIndex];
  if(slot.dead){
    logPush(`P${actorId+1} 狩人設定 → DEADは選べない`);
    return;
  }
  if(slot.role === ROLES.GUARD || slot.role === ROLES.WOLF){
    logPush(`P${actorId+1} 狩人設定 → 守れないカード（狩人/人狼）`);
    return;
  }

  pl.guardIndex = slotIndex;

  if(game.phase === PHASES.ROUND0_GUARD){
    logPush(`P${actorId+1} Round0 狩人守り → 設定完了（非公開）`);
    advanceRound0();
    return;
  }

  logPush(`P${actorId+1} 狩人守り設定 → 設定完了（非公開）`);
  advancePhase();
}

function resolveBite(actorId, targetId, slotIndex){
  const target = game.players[targetId];
  const slot = target.slots[slotIndex];
  if(slot.dead) return;

  const isWolf = (slot.role === ROLES.WOLF);
  const isGuarded = (target.guardIndex === slotIndex);

  if(isWolf || isGuarded){
    logPush(`P${actorId+1} 噛み → P${targetId+1} S${slotIndex+1}（不発：理由は非公開）`);
  } else {
    killSlot(targetId, slotIndex);
    logPush(`P${actorId+1} 噛み → P${targetId+1} S${slotIndex+1}（DEAD：理由は非公開）`);
    updateAfterKill();
  }

  if(!game.over) advancePhase();
}

/* ======================
   不在→OK と 自動
====================== */
function canAbsentOk(){
  if(game.over) return false;
  if(game.turn !== CONFIG.humanPlayerId) return false;

  const actor = game.players[game.turn];
  if(game.phase === PHASES.SEER) return !hasRoleAlive(actor, ROLES.SEER);
  if(game.phase === PHASES.MAD)  return (!hasRoleAlive(actor, ROLES.MAD) || actor.madUsed);
  if(game.phase === PHASES.GUARD)return !hasRoleAlive(actor, ROLES.GUARD);

  if(game.phase === PHASES.ROUND0_MAD)   return !hasRoleAlive(actor, ROLES.MAD);
  if(game.phase === PHASES.ROUND0_GUARD) return !hasRoleAlive(actor, ROLES.GUARD);
  return false;
}

function doAbsentOk(){
  if(!canAbsentOk()) return;
  const actorId = game.turn;

  if(game.phase === PHASES.SEER){ logPush(`P${actorId+1} 占い不在 → OK（スキップ）`); advancePhase(); return; }
  if(game.phase === PHASES.MAD){  logPush(`P${actorId+1} 狂人：スキップ`); advancePhase(); return; }
  if(game.phase === PHASES.GUARD){logPush(`P${actorId+1} 狩人不在 → OK（スキップ）`); advancePhase(); return; }

  if(game.phase === PHASES.ROUND0_MAD){
    logPush(`P${actorId+1} 狂人不在 → OK（OFF扱い）`);
    resolveMadRound0Off(actorId);
    return;
  }
  if(game.phase === PHASES.ROUND0_GUARD){
    logPush(`P${actorId+1} 狩人不在 → OK（スキップ）`);
    advanceRound0();
    return;
  }
}

function timeoutAutoOne(){
  if(game.over) return;

  const actorId = game.turn;
  const actor = game.players[actorId];

  // 生存者1人などで left/right が null になるケースに備えてガード
  const left = leftPlayerIndex(actorId);
  const right = rightPlayerIndex(actorId);

  if(game.phase === PHASES.ROUND0_MAD){
    logPush(`タイムアウト: P${actorId+1} Round0 狂人 → 未操作（OFF扱い）`);
    resolveMadRound0Off(actorId);
    return;
  }

  if(game.phase === PHASES.ROUND0_GUARD){
    if(!hasRoleAlive(actor, ROLES.GUARD)){
      logPush(`タイムアウト: P${actorId+1} 狩人不在 → OK（スキップ）`);
      advanceRound0();
      return;
    }
    if(actor.guardIndex !== null){
      logPush(`タイムアウト: P${actorId+1} Round0 狩人守り → 維持`);
      advanceRound0();
      return;
    }
    const act = getGuardableSlotIndices(actor);
    if(act.length === 0){
      logPush(`タイムアウト: P${actorId+1} Round0 狩人守り → 守れるスロットなし（進行のみ）`);
      advanceRound0();
      return;
    }
    const pick = act[Math.floor(Math.random()*act.length)];
    logPush(`タイムアウト: P${actorId+1} Round0 狩人守り → ランダム強制`);
    resolveGuard(actorId, pick);
    return;
  }

  if(game.phase === PHASES.SEER){
    if(!hasRoleAlive(actor, ROLES.SEER)){
      logPush(`タイムアウト: P${actorId+1} 占い不在 → OK（スキップ）`);
      advancePhase();
      return;
    }
    if(left === null){ logPush(`タイムアウト: 左が存在しない → 進行のみ`); advancePhase(); return; }
    const tgt = game.players[left];
    const act = getAliveSlotIndices(tgt);
    if(act.length===0){ logPush(`タイムアウト: 左に生存スロットなし → 進行のみ`); advancePhase(); return; }
    const pick = act[Math.floor(Math.random()*act.length)];
    logPush(`タイムアウト: P${actorId+1} 占い → 左の生存スロットからランダム（全体公開）`);
    resolveSeer(actorId, left, pick);
    return;
  }

  if(game.phase === PHASES.LYNCH){
    if(left === null){ logPush(`タイムアウト: 左が存在しない → 進行のみ`); advancePhase(); return; }
    const tgt = game.players[left];
    const act = getAliveSlotIndices(tgt);
    if(act.length===0){ logPush(`タイムアウト: 左に生存スロットなし → 進行のみ`); advancePhase(); return; }
    const pick = act[Math.floor(Math.random()*act.length)];
    logPush(`タイムアウト: P${actorId+1} 吊り → 左の生存スロットからランダム`);
    resolveLynch(actorId, left, pick);
    return;
  }

  if(game.phase === PHASES.MAD){
    if(!hasRoleAlive(actor, ROLES.MAD) || actor.madUsed){
      logPush(`タイムアウト: P${actorId+1} 狂人：スキップ`);
      advancePhase();
      return;
    }
    if(!actor.madEnabled){
      logPush(`タイムアウト: P${actorId+1} 狂人設定 → OFF（スキップ）`);
      advancePhase();
      return;
    }
    logPush(`タイムアウト: P${actorId+1} 狂人設定 → 維持`);
    advancePhase();
    return;
  }

  if(game.phase === PHASES.GUARD){
    if(!hasRoleAlive(actor, ROLES.GUARD)){
      logPush(`タイムアウト: P${actorId+1} 狩人不在 → OK（スキップ）`);
      advancePhase();
      return;
    }
    if(actor.guardIndex !== null){
      logPush(`タイムアウト: P${actorId+1} 狩人守り → 維持`);
      advancePhase();
      return;
    }
    const act = getGuardableSlotIndices(actor);
    if(act.length === 0){
      logPush(`タイムアウト: P${actorId+1} 狩人守り → 守れるスロットなし（進行のみ）`);
      advancePhase();
      return;
    }
    const pick = act[Math.floor(Math.random()*act.length)];
    logPush(`タイムアウト: P${actorId+1} 狩人守り → 未設定のためランダム強制`);
    resolveGuard(actorId, pick);
    return;
  }

  if(game.phase === PHASES.BITE){
    if(right === null){ logPush(`タイムアウト: 右が存在しない → 進行のみ`); advancePhase(); return; }
    const tgt = game.players[right];
    const act = getAliveSlotIndices(tgt);
    if(act.length===0){ logPush(`タイムアウト: 右に生存スロットなし → 進行のみ`); advancePhase(); return; }
    const pick = act[Math.floor(Math.random()*act.length)];
    logPush(`タイムアウト: P${actorId+1} 噛み → 右の生存スロットからランダム`);
    resolveBite(actorId, right, pick);
    return;
  }
}

function isHumanTurn(){
  if(!CONFIG.autoPlayers) return true;
  return game.turn === CONFIG.humanPlayerId || game.over || game.phase === PHASES.END;
}

function runAutoUntilHumanTurn(){
  if(!CONFIG.autoPlayers) return;
  let steps = 0;
  while(!game.over && game.phase !== PHASES.END && !isHumanTurn()){
    steps += 1;
    if(steps > CONFIG.autoSafetySteps){
      logPush(`自動停止: safetySteps超過（無限ループ防止）`);
      break;
    }
    timeoutAutoOne();
  }
}

/* ======================
   描画
====================== */
function renderStock(){
  const el = document.getElementById("stock");
  el.innerHTML = "";

  const title = document.createElement("div");
  title.textContent = "【占い履歴（全体公開）】";
  el.appendChild(title);

  if(game.stock.seerHistory.length === 0){
    const none = document.createElement("div");
    none.textContent = "（まだありません）";
    el.appendChild(none);
    return;
  }

  for(const h of game.stock.seerHistory){
    const row = document.createElement("div");
    row.className = "stockRow";

    const icon = document.createElement("img");
    icon.className = "stockIcon";
    icon.alt = h.result;
    icon.src = (h.result === "黒") ? MARK_ICON.BLACK : MARK_ICON.WHITE;
    row.appendChild(icon);

    const txt = document.createElement("div");
    const inv = h.wasInverted ? " ※反転" : "";
    const chg = h.changedLast ? "（変化）" : "";
    txt.textContent = `#${h.actionNo} [${h.ts}] P${h.actorId+1} → P${h.targetId+1} S${h.slotIndex+1} = ${h.result}${chg}${inv}`;
    row.appendChild(txt);

    el.appendChild(row);
  }
}

function renderMedium(viewAsId){
  const viewAs = game.players[viewAsId];
  const mi = document.getElementById("mediumInfo");
  const mediumAlive = hasRoleAlive(viewAs, ROLES.MEDIUM);

  let wolfArr = null;
  if(mediumAlive){
    wolfArr = game.players.map(p=>wolfCount(p));
  } else if(viewAs.mediumWolfSnapshot){
    wolfArr = viewAs.mediumWolfSnapshot;
  }

  if(wolfArr){
    mi.innerHTML = `
      <div><b>霊媒表示（View as が霊媒保持のとき）</b></div>
      <div class="mini">${wolfArr.map((c,i)=>`P${i+1}: 人狼${c}`).join(" / ")}</div>
      ${mediumAlive ? "" : `<div class="mini">（霊媒死亡後の固定表示）</div>`}
    `;
  } else {
    mi.innerHTML = `<div class="mini">（霊媒表示なし）</div>`;
  }
}

function render(){
  // View as
  const viewSel = document.getElementById("viewAs");
  if(viewSel.options.length === 0){
    for(let i=0;i<4;i++){
      const opt = document.createElement("option");
      opt.value = String(i);
      opt.textContent = `P${i+1}`;
      viewSel.appendChild(opt);
    }
  }
  const viewAsId = Number(viewSel.value || "0");
  const viewAs = game.players[viewAsId];

  const actorId = game.turn;
  const actor = game.players[actorId];
  const left = leftPlayerIndex(actorId);
  const right = rightPlayerIndex(actorId);

  const seerAbsent = (game.phase === PHASES.SEER && !hasRoleAlive(actor, ROLES.SEER));
  const madAbsent  = (game.phase === PHASES.MAD  && (!hasRoleAlive(actor, ROLES.MAD) || actor.madUsed));
  const grdAbsent  = (game.phase === PHASES.GUARD&& !hasRoleAlive(actor, ROLES.GUARD));
  const r0MadAbsent= (game.phase === PHASES.ROUND0_MAD && !hasRoleAlive(actor, ROLES.MAD));
  const r0GrdAbsent= (game.phase === PHASES.ROUND0_GUARD && !hasRoleAlive(actor, ROLES.GUARD));

  // 状態表示
  let statusHtml = `
    <div class="big"><b>フェーズ</b>: ${game.phase}</div>
    <div><b>手番</b>: P${actorId+1} ${actor.alive ? "" : '<span class="danger">(リタイヤ)</span>'}
      ${CONFIG.autoPlayers ? `<span class="badge">自動: P2〜P4</span>` : ""}
    </div>
    <div class="mini">左: ${left===null ? "-" : `P${left+1}`} ／ 右: ${right===null ? "-" : `P${right+1}`}</div>
  `;

  if(!game.over){
    if(game.phase === PHASES.ROUND0_MAD){
      statusHtml += `<div class="hint">Round0（狂人）: 自分のスロットを1つ選んで「反転対象」 / もしくはOFF</div>`;
      statusHtml += r0MadAbsent ? `<div class="noteBox"><b>狂人不在</b> → OK（OFF扱い）。「不在→OK」でも進行できる。</div>` : ``;
    } else if(game.phase === PHASES.ROUND0_GUARD){
      statusHtml += `<div class="hint">Round0（狩人）: 自分の守りスロットを選ぶ（狩人/人狼は守れない）</div>`;
      statusHtml += r0GrdAbsent ? `<div class="noteBox"><b>狩人不在</b> → OK（スキップ）。「不在→OK」でも進行できる。</div>` : ``;
    } else if(game.phase === PHASES.SEER){
      statusHtml += `<div class="hint">占い: 左のスロットを選ぶ → 白/黒が全体公開</div>`;
      statusHtml += seerAbsent ? `<div class="noteBox"><b>占い不在</b> → OK（スキップ）。「不在→OK」でも進行できる。</div>` : ``;
    } else if(game.phase === PHASES.LYNCH){
      statusHtml += `<div class="hint">吊り: 左のスロットを1つ選んでDEADにする</div>`;
    } else if(game.phase === PHASES.MAD){
      statusHtml += `<div class="hint">狂人: 反転対象スロットを選ぶ（発動済みならスキップのみ）</div>`;
      statusHtml += madAbsent ? `<div class="noteBox"><b>狂人：選択不可</b> → OK（スキップ）。</div>` : ``;
    } else if(game.phase === PHASES.GUARD){
      statusHtml += `<div class="hint">狩人: 守りスロットを選ぶ（狩人/人狼は守れない）</div>`;
      statusHtml += grdAbsent ? `<div class="noteBox"><b>狩人不在</b> → OK（スキップ）。</div>` : ``;
    } else if(game.phase === PHASES.BITE){
      statusHtml += `<div class="hint">噛み: 右のスロットを1つ選ぶ（人狼/守り一致は不発）</div>`;
    }
  }

  if(game.phase === PHASES.END){
    statusHtml += `<div class="danger" style="margin-top:6px;">勝者: ${game.winners.map(id=>`P${id+1}`).join(", ")}</div>`;
  }
  document.getElementById("status").innerHTML = statusHtml;

  // ボタン有効/無効
  document.getElementById("btnRound0MadOff").disabled = !(game.phase === PHASES.ROUND0_MAD && !game.over && game.turn===CONFIG.humanPlayerId);
  document.getElementById("btnMadKeep").disabled = !(game.phase === PHASES.MAD && !game.over && game.turn===CONFIG.humanPlayerId);
  document.getElementById("btnMadClear").disabled = !(game.phase === PHASES.MAD && !game.over && game.turn===CONFIG.humanPlayerId);

  document.getElementById("btnGuardKeep").disabled = !(
    (game.phase === PHASES.GUARD || game.phase === PHASES.ROUND0_GUARD) &&
    !game.over &&
    game.turn===CONFIG.humanPlayerId
  );

  document.getElementById("btnAbsentOk").disabled = !canAbsentOk();

  // 占い履歴
  renderStock();

  // 霊媒表示（View as本人だけ）
  renderMedium(viewAsId);

  // ログ
  document.getElementById("log").textContent = game.log.join("\n");

  // プレイヤー描画
  const playersDiv = document.getElementById("players");
  playersDiv.innerHTML = "";

  const actorId2 = game.turn;
  const actor2 = game.players[actorId2];
  const left2 = leftPlayerIndex(actorId2);
  const right2 = rightPlayerIndex(actorId2);

  const seerAbsentNow = (game.phase === PHASES.SEER && !hasRoleAlive(actor2, ROLES.SEER));
  const madAbsentNow  = (game.phase === PHASES.MAD  && (!hasRoleAlive(actor2, ROLES.MAD) || actor2.madUsed));
  const grdAbsentNow  = (game.phase === PHASES.GUARD&& !hasRoleAlive(actor2, ROLES.GUARD));
  const r0MadAbsentNow= (game.phase === PHASES.ROUND0_MAD && !hasRoleAlive(actor2, ROLES.MAD));
  const r0GrdAbsentNow= (game.phase === PHASES.ROUND0_GUARD && !hasRoleAlive(actor2, ROLES.GUARD));

  for(const pl of game.players){
    const pDiv = document.createElement("div");
    pDiv.className = "player" + (pl.alive ? "" : " dead");

    const villageTotal = villageRolesTotal(pl);
    const isSelf = (pl.id === viewAsId);

    const showMadOn = isSelf ? (hasRoleAlive(pl, ROLES.MAD) ? (pl.madUsed ? "発動済" : (pl.madEnabled ? "ON" : "OFF")) : "DEAD/不在") : "-";
    const showInvert = isSelf ? (pl.madUsed ? "-" : (pl.invertIndex===null ? "-" : `S${pl.invertIndex+1}`)) : "-";
    const showGuard  = isSelf ? (pl.guardIndex===null ? "-" : `S${pl.guardIndex+1}`) : "-";

    const head = document.createElement("div");
    head.innerHTML = `
      <div>
        <b>P${pl.id+1}</b>
        ${pl.alive ? "" : `<span class="badge">リタイヤ</span>`}
        <span class="badge">村役職残数:${villageTotal}</span>
      </div>
      <div class="mini">
        狂人:${showMadOn} ／ 反転:${showInvert} ／ 守り:${showGuard}
      </div>
    `;
    pDiv.appendChild(head);

    const slotsDiv = document.createElement("div");
    slotsDiv.className = "slots";

    for(let i=0;i<pl.slots.length;i++){
      const s = pl.slots[i];
      const b = document.createElement("div");
      b.className = "slot" + (s.dead ? " deadslot" : "");
      b.innerHTML = `<div>S${i+1}</div>`;

      // View as本人だけ役職アイコン表示（生存時のみ）
      if(pl.id === viewAsId && !s.dead){
        const img = document.createElement("img");
        img.className = "roleIcon";
        img.src = ROLE_ICON[s.role] || "";
        img.alt = s.role;
        b.appendChild(img);
      }

      // 左上：盾（View as本人だけ）
      if(pl.id === viewAsId && pl.guardIndex === i){
        const img = document.createElement("img");
        img.className = "cornerIcon cornerTL";
        img.src = BADGE_ICON.SHIELD;
        img.alt = "守り";
        b.appendChild(img);
      }

      // 右上：反転（View as本人だけ / 発動後は表示しない）
      if(pl.id === viewAsId && pl.invertIndex === i && !pl.madUsed){
        const img = document.createElement("img");
        img.className = "cornerIcon cornerTR";
        img.src = BADGE_ICON.ROTATE;
        img.alt = "反転";
        b.appendChild(img);
      }

      // 右下：白黒（全体公開：死亡後も残す）
      if(s.publicSeer && s.publicSeer.last){
        const img = document.createElement("img");
        img.className = "cornerIcon cornerBR";
        img.src = (s.publicSeer.last === "黒") ? MARK_ICON.BLACK : MARK_ICON.WHITE;
        img.alt = "占い結果";
        b.appendChild(img);
      }

      // 選択可/不可の強調（P1手番のみ）
      if(!game.over && actorId2 === CONFIG.humanPlayerId){
        let canPick = false;
        let hintpick = false;
        let inTargetArea = false;

        // Round0 狂人（自分のみ）
        if(!s.dead && game.phase === PHASES.ROUND0_MAD && pl.id === actorId2){
          inTargetArea = true;
          if(r0MadAbsentNow) hintpick = true; else canPick = true;
        }

        // Round0 狩人（自分のみ）
        if(!s.dead && game.phase === PHASES.ROUND0_GUARD && pl.id === actorId2){
          inTargetArea = true;
          if(r0GrdAbsentNow) hintpick = true;
          else if(!(s.role === ROLES.GUARD || s.role === ROLES.WOLF)) canPick = true;
        }

        // 占い（左のみ）
        if(!s.dead && game.phase === PHASES.SEER && left2 !== null && pl.id === left2){
          inTargetArea = true;
          if(seerAbsentNow) hintpick = true; else canPick = true;
        }

        // 吊り（左のみ）
        if(!s.dead && game.phase === PHASES.LYNCH && left2 !== null && pl.id === left2){
          inTargetArea = true;
          canPick = true;
        }

        // 狂人設定（自分のみ）
        if(!s.dead && game.phase === PHASES.MAD && pl.id === actorId2){
          inTargetArea = true;
          if(madAbsentNow) hintpick = true;
          else if(actor2.madEnabled && !actor2.madUsed) canPick = true;
          else hintpick = true;
        }

        // 狩人設定（自分のみ）
        if(!s.dead && game.phase === PHASES.GUARD && pl.id === actorId2){
          inTargetArea = true;
          if(grdAbsentNow) hintpick = true;
          else if(!(s.role === ROLES.GUARD || s.role === ROLES.WOLF)) canPick = true;
        }

        // 噛み（右のみ）
        if(!s.dead && game.phase === PHASES.BITE && right2 !== null && pl.id === right2){
          inTargetArea = true;
          canPick = true;
        }

        if(canPick) b.classList.add("canPick");
        else if(hintpick) b.classList.add("hintpick");

        if(inTargetArea && !canPick && !hintpick && !s.dead){
          b.classList.add("cantPick");
        }
      }

      // クリック
      if(!s.dead){
        b.addEventListener("click", ()=>clickSlot(pl.id, i));
      }
      slotsDiv.appendChild(b);
    }

    pDiv.appendChild(slotsDiv);
    playersDiv.appendChild(pDiv);
  }
}

/* ======================
   操作（クリック）
====================== */
function renderAndAuto(){
  render();
  runAutoUntilHumanTurn();
  render();
}

function clickSlot(playerId, slotIndex){
  if(game.over) return;

  const actorId = game.turn;
  if(CONFIG.autoPlayers && actorId !== CONFIG.humanPlayerId) return;

  const pl = game.players[playerId];
  const slot = pl.slots[slotIndex];
  if(slot.dead) return;

  const left = leftPlayerIndex(actorId);
  const right = rightPlayerIndex(actorId);

  if(game.phase === PHASES.ROUND0_MAD){
    if(playerId !== actorId) return;
    resolveMadRound0Pick(actorId, slotIndex);
    renderAndAuto();
    return;
  }

  if(game.phase === PHASES.ROUND0_GUARD){
    if(playerId !== actorId) return;
    resolveGuard(actorId, slotIndex);
    renderAndAuto();
    return;
  }

  if(game.phase === PHASES.SEER){
    if(left === null) return;
    if(playerId !== left) return;
    resolveSeer(actorId, left, slotIndex);
    renderAndAuto();
    return;
  }

  if(game.phase === PHASES.LYNCH){
    if(left === null) return;
    if(playerId !== left) return;
    resolveLynch(actorId, left, slotIndex);
    renderAndAuto();
    return;
  }

  if(game.phase === PHASES.MAD){
    if(playerId !== actorId) return;
    resolveMad(actorId, slotIndex);
    renderAndAuto();
    return;
  }

  if(game.phase === PHASES.GUARD){
    if(playerId !== actorId) return;
    resolveGuard(actorId, slotIndex);
    renderAndAuto();
    return;
  }

  if(game.phase === PHASES.BITE){
    if(right === null) return;
    if(playerId !== right) return;
    resolveBite(actorId, right, slotIndex);
    renderAndAuto();
    return;
  }
}

/* ======================
   ボタン / 起動
====================== */
function bind(){
  document.getElementById("btnNew").addEventListener("click", ()=>{
    game = makeNewGame(null);
    baseDeal = game.players.map(p=>p.slots.map(s=>s.role));
    logPush("新規ゲーム開始（配り直し）");
    renderAndAuto();
  });

  document.getElementById("btnReset").addEventListener("click", ()=>{
    if(!baseDeal){
      game = makeNewGame(null);
      baseDeal = game.players.map(p=>p.slots.map(s=>s.role));
      logPush("新規ゲーム開始（配り直し）");
    } else {
      game = makeNewGame(baseDeal);
      logPush("同じ配りでリセット");
    }
    renderAndAuto();
  });

  document.getElementById("btnAutoOne").addEventListener("click", ()=>{
    timeoutAutoOne();
    renderAndAuto();
  });

  document.getElementById("btnRound0MadOff").addEventListener("click", ()=>{
    if(game.phase !== PHASES.ROUND0_MAD || game.over) return;
    if(game.turn !== CONFIG.humanPlayerId) return;
    resolveMadRound0Off(game.turn);
    renderAndAuto();
  });

  document.getElementById("btnMadKeep").addEventListener("click", ()=>{
    if(game.phase !== PHASES.MAD || game.over) return;
    if(game.turn !== CONFIG.humanPlayerId) return;
    resolveMad(game.turn, null);
    renderAndAuto();
  });

  document.getElementById("btnMadClear").addEventListener("click", ()=>{
    if(game.phase !== PHASES.MAD || game.over) return;
    if(game.turn !== CONFIG.humanPlayerId) return;
    resolveMadClear(game.turn);
    renderAndAuto();
  });

  document.getElementById("btnGuardKeep").addEventListener("click", ()=>{
    if(!((game.phase === PHASES.GUARD || game.phase === PHASES.ROUND0_GUARD) && !game.over)) return;
    if(game.turn !== CONFIG.humanPlayerId) return;

    const actor = game.players[game.turn];

    if(!hasRoleAlive(actor, ROLES.GUARD)){
      logPush(`P${game.turn+1} 狩人不在 → OK（スキップ）`);
      if(game.phase === PHASES.ROUND0_GUARD) advanceRound0(); else advancePhase();
      renderAndAuto();
      return;
    }

    if(actor.guardIndex === null){
      logPush(`P${game.turn+1} 狩人守り → 未設定のため維持不可（スロットを選択）`);
      renderAndAuto();
      return;
    }

    logPush(`P${game.turn+1} 狩人守り → 維持`);
    if(game.phase === PHASES.ROUND0_GUARD) advanceRound0(); else advancePhase();
    renderAndAuto();
  });

  document.getElementById("btnAbsentOk").addEventListener("click", ()=>{
    doAbsentOk();
    renderAndAuto();
  });

  document.getElementById("viewAs").addEventListener("change", ()=>{
    render();
  });
}

function init(){
  game = makeNewGame(null);
  baseDeal = game.players.map(p=>p.slots.map(s=>s.role));
  logPush("準備完了：新規ゲーム or リセットで開始");
  bind();
  renderAndAuto();
}

init();
  </script>
</body>
</html>